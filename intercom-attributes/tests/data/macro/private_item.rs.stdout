#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate intercom;
use intercom::*;

trait IFoo {
    fn trait_method(&self);
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
struct __IntercomVtableForIFoo_Automation {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub trait_method: unsafe extern "system" fn(
        self_vtable: intercom::RawComPtr,
    ) -> <() as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem> for dyn IFoo {
    type VTable = __IntercomVtableForIFoo_Automation;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
        }
    }
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
struct __IntercomVtableForIFoo_Raw {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub trait_method: unsafe extern "system" fn(
        self_vtable: intercom::RawComPtr,
    ) -> <() as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem> for dyn IFoo {
    type VTable = __IntercomVtableForIFoo_Raw;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
        }
    }
}
#[allow(clippy::all)]
impl IFoo for intercom::ComItf<dyn IFoo> {
    fn trait_method(&self) -> () {
        intercom::logging::trace(|l| {
            l(
                "testcrate",
                ::core::fmt::Arguments::new_v1(
                    &["[", "] Calling ", "::"],
                    &match (&self, &"IFoo", &"trait_method") {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                ),
            )
        });
        #[allow(unused_imports)]
        use intercom::ErrorValue;
        if let Some(comptr) =
            intercom::ComItf::maybe_ptr::<intercom::type_system::AutomationTypeSystem>(self)
        {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", with ", "] Calling ", "::", ", type system: "],
                        &match (&self, &comptr.ptr, &"IFoo", &"trait_method", &"Automation") {
                            (arg0, arg1, arg2, arg3, arg4) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            #[allow(unused_imports)]
            let vtbl = comptr.ptr
                as *const *const <dyn IFoo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
            #[allow(unused_unsafe)]
            let __intercom_result: Result<(), intercom::ComError> = (|| unsafe {
                let __result = ((**vtbl).trait_method)(comptr.ptr);
                let __intercom_iid = intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                };
                Ok({})
            })();
            return match __intercom_result {
                Ok(v) => v,
                Err(err) => <() as intercom::ErrorValue>::from_com_error(err),
            };
        }
        if let Some(comptr) =
            intercom::ComItf::maybe_ptr::<intercom::type_system::RawTypeSystem>(self)
        {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", with ", "] Calling ", "::", ", type system: "],
                        &match (&self, &comptr.ptr, &"IFoo", &"trait_method", &"Raw") {
                            (arg0, arg1, arg2, arg3, arg4) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            #[allow(unused_imports)]
            let vtbl = comptr.ptr
                as *const *const <dyn IFoo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::VTable;
            #[allow(unused_unsafe)]
            let __intercom_result: Result<(), intercom::ComError> = (|| unsafe {
                let __result = ((**vtbl).trait_method)(comptr.ptr);
                let __intercom_iid = intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
                };
                Ok({})
            })();
            return match __intercom_result {
                Ok(v) => v,
                Err(err) => <() as intercom::ErrorValue>::from_com_error(err),
            };
        }
        <() as intercom::ErrorValue>::from_com_error(intercom::ComError::E_POINTER.into())
    }
}
impl intercom::ComInterface for dyn IFoo {
    #[doc = "Returns the IID of the requested interface."]
    fn iid_ts<TS: intercom::type_system::TypeSystem>() -> &'static intercom::IID
    where
        Self: intercom::attributes::ComInterface<TS>,
    {
        <Self as intercom::attributes::ComInterface<TS>>::iid()
    }
    fn iid(ts: intercom::type_system::TypeSystemName) -> Option<&'static intercom::IID> {
        match ts {
            intercom::type_system::TypeSystemName::Automation => {
                Some(<Self as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid())
            }
            intercom::type_system::TypeSystemName::Raw => {
                Some(<Self as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid())
            }
        }
    }
    fn deref(com_itf: &intercom::ComItf<dyn IFoo>) -> &(dyn IFoo + 'static) {
        com_itf
    }
}
impl intercom::type_system::ForeignType for dyn IFoo {
    #[doc = r" The name of the type."]
    fn type_name() -> &'static str {
        "IFoo"
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
impl intercom::attributes::InterfaceHasTypeInfo for dyn IFoo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let variants = <[_]>::into_vec(box [
            intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                ts: intercom::type_system::TypeSystemName::Automation,
                iid: intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                },
                methods: <[_]>::into_vec(box [intercom::ComBox::new(intercom::typelib::Method {
                    name: "trait_method".into(),
                    return_type: intercom::typelib::Arg {
                        name: "".into(),
                        ty: "void".into(),
                        indirection_level: 0,
                        direction: intercom::typelib::Direction::Return,
                    },
                    parameters: <[_]>::into_vec(box []),
                })]),
            }),
            intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                ts: intercom::type_system::TypeSystemName::Raw,
                iid: intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8],
                },
                methods: <[_]>::into_vec(box [intercom::ComBox::new(intercom::typelib::Method {
                    name: "trait_method".into(),
                    return_type: intercom::typelib::Arg {
                        name: "".into(),
                        ty: "void".into(),
                        indirection_level: 0,
                        direction: intercom::typelib::Direction::Return,
                    },
                    parameters: <[_]>::into_vec(box []),
                })]),
            }),
        ]);
        <[_]>::into_vec(box [intercom::typelib::TypeInfo::Interface(
            intercom::ComBox::new(intercom::typelib::Interface {
                name: "IFoo".into(),
                variants: variants,
                options: intercom::typelib::InterfaceOptions {
                    class_impl_interface: false,
                    ..Default::default()
                },
            }),
        )])
    }
}
struct Foo;
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Raw as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<dyn IFoo, intercom::type_system::AutomationTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().IFoo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<dyn IFoo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().IFoo_Raw as *const _ as usize }
    }
}
#[allow(non_upper_case_globals)]
impl
    intercom::attributes::ComImpl<
        intercom::ISupportErrorInfo,
        intercom::type_system::AutomationTypeSystem,
    > for Foo
{
    fn vtable()
     ->
         &'static <dyn intercom::ISupportErrorInfo as
intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable{
        type T = <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type Vtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                Vtbl {
                    query_interface: intercom::ComBoxData::<Foo>::query_interface_ptr,
                    add_ref: intercom::ComBoxData::<Foo>::add_ref_ptr,
                    release: intercom::ComBoxData::<Foo>::release_ptr,
                }
            },
            interface_supports_error_info:
                intercom::ComBoxData::<Foo>::interface_supports_error_info_ptr,
        }
    }
}
impl intercom::HasInterface<intercom::IUnknown> for Foo {}
#[allow(non_snake_case)]
#[doc(hidden)]
struct __intercom_vtable_for_Foo {
    _ISupportErrorInfo:
        &'static <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable,
    Foo_Automation: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    Foo_Raw: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
    IFoo_Automation: &'static <dyn IFoo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    IFoo_Raw: &'static <dyn IFoo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
}
#[allow(clippy::all)]
impl intercom::CoClass for Foo {
    type VTableList = __intercom_vtable_for_Foo;
    fn create_vtable_list() -> Self::VTableList {
        __intercom_vtable_for_Foo {
            _ISupportErrorInfo: <Foo as intercom::attributes::ComImpl<
                dyn intercom::ISupportErrorInfo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Automation: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Raw: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::RawTypeSystem,
            >>::vtable(),
            IFoo_Automation: <Foo as intercom::attributes::ComImpl<
                dyn IFoo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            IFoo_Raw: <Foo as intercom::attributes::ComImpl<
                dyn IFoo,
                intercom::type_system::RawTypeSystem,
            >>::vtable(),
        }
    }
    fn query_interface(
        vtables: &Self::VTableList,
        riid: intercom::REFIID,
    ) -> intercom::RawComResult<intercom::RawComPtr> {
        if riid.is_null() {
            intercom::logging::error(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", "] ", "::query_interface(NULL)"],
                        &match (&vtables, &"Foo") {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            return Err(intercom::raw::E_NOINTERFACE);
        }
        unsafe {
            let riid = &*riid;
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1_formatted(
                        &["[", "] ", "::query_interface(", ")"],
                        &match (&vtables, &"Foo", &riid) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::UpperHex::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(0usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(1usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: ::core::fmt::rt::v1::Position::At(2usize),
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 2u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ),
                )
            });
            Ok(
                if riid
                    == <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> IUnknown [", "]"],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr =
                       (&vtables._ISupportErrorInfo) as
                           *const &<dyn intercom::ISupportErrorInfo as
                                   intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as
                           *mut &<dyn intercom::ISupportErrorInfo as
                                 intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                           as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &[
                                    "[",
                                    "] ",
                                    "::query_interface(",
                                    ") -> ISupportErrorInfo [",
                                    "]",
                                ],
                                &match (&vtables, &"Foo", &riid, &ptr) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Automation
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Automation", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::RawTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.Foo_Raw
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"Foo", &"Raw", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <dyn IFoo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.IFoo_Automation
                        as *const &<dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable
                        as *mut &<dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"IFoo", &"Automation", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else if riid
                    == <dyn IFoo as intercom::attributes::ComInterface<
                        intercom::type_system::RawTypeSystem,
                    >>::iid()
                {
                    let ptr = &vtables.IFoo_Raw
                        as *const &<dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable
                        as *mut &<dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable as intercom::RawComPtr;
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> ", " (", ") [", "]"],
                                &match (&vtables, &"Foo", &riid, &"IFoo", &"Raw", &ptr) {
                                    (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg3,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg4,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg5,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(3usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(4usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(5usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    ptr
                } else {
                    intercom::logging::trace(|l| {
                        l(
                            "testcrate",
                            ::core::fmt::Arguments::new_v1_formatted(
                                &["[", "] ", "::query_interface(", ") -> E_NOINTERFACE"],
                                &match (&vtables, &"Foo", &riid) {
                                    (arg0, arg1, arg2) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Pointer::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::UpperHex::fmt,
                                        ),
                                    ],
                                },
                                &[
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(0usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(1usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::core::fmt::rt::v1::Argument {
                                        position: ::core::fmt::rt::v1::Position::At(2usize),
                                        format: ::core::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                                            flags: 2u32,
                                            precision: ::core::fmt::rt::v1::Count::Implied,
                                            width: ::core::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ),
                        )
                    });
                    return Err(intercom::raw::E_NOINTERFACE);
                },
            )
        }
    }
    fn interface_supports_error_info(riid: intercom::REFIID) -> bool {
        if riid.is_null() {
            return false;
        }
        unsafe {
            let riid = &*riid;
            if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <dyn IFoo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <dyn IFoo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid()
            {
                true
            } else {
                false
            }
        }
    }
}
#[allow(non_upper_case_globals)]
#[doc = "`Foo` class ID."]
pub const CLSID_Foo: intercom::CLSID = intercom::GUID {
    data1: 0u32,
    data2: 0u16,
    data3: 0u16,
    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
};
impl intercom::attributes::HasTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let mut r = <[_]>::into_vec(box [intercom::typelib::TypeInfo::Class(
            intercom::ComBox::new(intercom::typelib::CoClass::__new(
                "Foo".into(),
                intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
                },
                <[_]>::into_vec(box [
                    intercom::typelib::InterfaceRef {
                        name: "Foo".into(),
                        iid_automation: <Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::iid()
                        .clone(),
                        iid_raw: <Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::iid()
                        .clone(),
                    },
                    intercom::typelib::InterfaceRef {
                        name: "IFoo".into(),
                        iid_automation: <dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::iid()
                        .clone(),
                        iid_raw: <dyn IFoo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::iid()
                        .clone(),
                    },
                ]),
            )),
        )]);
        r.extend(<Foo as intercom::attributes::InterfaceHasTypeInfo>::gather_type_info());
        r.extend(<dyn IFoo as intercom::attributes::InterfaceHasTypeInfo>::gather_type_info());
        r
    }
}
impl Foo {
    pub fn struct_method(&self) {}
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_query_interface_Automation(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_add_ref_Automation(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_release_Automation(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_struct_method_Automation(self_vtable:
                                                                 intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            Foo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result:
            Result<<() as
                   intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"struct_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.struct_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"struct_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"struct_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    fn vtable() -> &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable {
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_query_interface_Automation,
                    add_ref: __Foo_Foo_add_ref_Automation,
                    release: __Foo_Foo_release_Automation,
                }
            },
            struct_method: __Foo_Foo_struct_method_Automation,
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_query_interface_Raw(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_add_ref_Raw(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_release_Raw(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_struct_method_Raw(self_vtable:
                                                          intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_combox =
        (self_vtable as usize -
             <Foo as
                 intercom::attributes::ComClass<Foo,
                                                intercom::type_system::RawTypeSystem>>::offset())
            as *mut intercom::ComBoxData<Foo>;
    let result:
            Result<<() as
                   intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"struct_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.struct_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"struct_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"struct_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::RawTypeSystem> for Foo {
    fn vtable()
     ->
         &'static <Foo as
intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::VTable{
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::RawTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_query_interface_Raw,
                    add_ref: __Foo_Foo_add_ref_Raw,
                    release: __Foo_Foo_release_Raw,
                }
            },
            struct_method: __Foo_Foo_struct_method_Raw,
        }
    }
}
impl intercom::HasInterface<Foo> for Foo {}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
pub struct __IntercomVtableForFoo_Automation {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub struct_method: unsafe extern "system" fn(
        self_vtable: intercom::RawComPtr,
    )
        -> <() as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem> for Foo {
    type VTable = __IntercomVtableForFoo_Automation;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8],
        }
    }
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[repr(C)]
#[doc(hidden)]
pub struct __IntercomVtableForFoo_Raw {
    pub __base: <dyn intercom::IUnknown as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    pub struct_method: unsafe extern "system" fn(
        self_vtable: intercom::RawComPtr,
    )
        -> <() as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[doc(hidden)]
impl intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem> for Foo {
    type VTable = __IntercomVtableForFoo_Raw;
    fn iid() -> &'static intercom::IID {
        &intercom::GUID {
            data1: 0u32,
            data2: 0u16,
            data3: 0u16,
            data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 3u8],
        }
    }
}
impl intercom::ComInterface for Foo {
    #[doc = "Returns the IID of the requested interface."]
    fn iid_ts<TS: intercom::type_system::TypeSystem>() -> &'static intercom::IID
    where
        Self: intercom::attributes::ComInterface<TS>,
    {
        <Self as intercom::attributes::ComInterface<TS>>::iid()
    }
    fn iid(ts: intercom::type_system::TypeSystemName) -> Option<&'static intercom::IID> {
        match ts {
            intercom::type_system::TypeSystemName::Automation => {
                Some(<Self as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid())
            }
            intercom::type_system::TypeSystemName::Raw => {
                Some(<Self as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid())
            }
        }
    }
    fn deref(com_itf: &intercom::ComItf<Foo>) -> &Foo {
        let some_iunk: &intercom::ComItf<dyn intercom::IUnknown> = com_itf.as_ref();
        let iunknown_iid =
            intercom::IUnknown::iid(intercom::type_system::TypeSystemName::Automation)
                .expect("IUnknown must have Automation IID");
        let primary_iunk = some_iunk
            .query_interface(iunknown_iid)
            .expect("All types must implement IUnknown");
        let combox: *mut intercom::ComBoxData<Foo> = primary_iunk as *mut intercom::ComBoxData<Foo>;
        unsafe {
            intercom::ComBoxData::release(combox);
            use std::ops::Deref;
            (*combox).deref()
        }
    }
}
impl intercom::type_system::ForeignType for Foo {
    #[doc = r" The name of the type."]
    fn type_name() -> &'static str {
        "Foo"
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
impl intercom::attributes::InterfaceHasTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let variants = <[_]>::into_vec(box [
            intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                ts: intercom::type_system::TypeSystemName::Automation,
                iid: intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 2u8],
                },
                methods: <[_]>::into_vec(box [intercom::ComBox::new(intercom::typelib::Method {
                    name: "struct_method".into(),
                    return_type: intercom::typelib::Arg {
                        name: "".into(),
                        ty: "void".into(),
                        indirection_level: 0,
                        direction: intercom::typelib::Direction::Return,
                    },
                    parameters: <[_]>::into_vec(box []),
                })]),
            }),
            intercom::ComBox::new(intercom::typelib::InterfaceVariant {
                ts: intercom::type_system::TypeSystemName::Raw,
                iid: intercom::GUID {
                    data1: 0u32,
                    data2: 0u16,
                    data3: 0u16,
                    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 3u8],
                },
                methods: <[_]>::into_vec(box [intercom::ComBox::new(intercom::typelib::Method {
                    name: "struct_method".into(),
                    return_type: intercom::typelib::Arg {
                        name: "".into(),
                        ty: "void".into(),
                        indirection_level: 0,
                        direction: intercom::typelib::Direction::Return,
                    },
                    parameters: <[_]>::into_vec(box []),
                })]),
            }),
        ]);
        <[_]>::into_vec(box [intercom::typelib::TypeInfo::Interface(
            intercom::ComBox::new(intercom::typelib::Interface {
                name: "Foo".into(),
                variants: variants,
                options: intercom::typelib::InterfaceOptions {
                    class_impl_interface: true,
                    ..Default::default()
                },
            }),
        )])
    }
}
impl IFoo for Foo {
    fn trait_method(&self) {}
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_query_interface_Automation(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            dyn IFoo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_add_ref_Automation(self_vtable:
                                                            intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            dyn IFoo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_release_Automation(self_vtable:
                                                            intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            dyn IFoo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_trait_method_Automation(self_vtable:
                                                                 intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_combox = (self_vtable as usize
        - <Foo as intercom::attributes::ComClass<
            dyn IFoo,
            intercom::type_system::AutomationTypeSystem,
        >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result:
            Result<<() as
                   intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"trait_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &dyn IFoo = &**self_combox;
                 let __result = self_struct.trait_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"trait_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"trait_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<dyn IFoo, intercom::type_system::AutomationTypeSystem> for Foo {
    fn vtable() -> &'static <dyn IFoo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable {
        type T = <dyn IFoo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_IFoo_query_interface_Automation,
                    add_ref: __Foo_IFoo_add_ref_Automation,
                    release: __Foo_IFoo_release_Automation,
                }
            },
            trait_method: __Foo_IFoo_trait_method_Automation,
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_query_interface_Raw(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternInput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternOutput<
        intercom::type_system::AutomationTypeSystem,
    >>::ForeignType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternOutput<
    intercom::type_system::AutomationTypeSystem,
>>::ForeignType {
    let self_ptr =
        (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                dyn IFoo,
                intercom::type_system::RawTypeSystem,
            >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::query_interface"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::query_interface(&mut *self_ptr, riid, out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_add_ref_Raw(self_vtable:
                                                     intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                dyn IFoo,
                intercom::type_system::RawTypeSystem,
            >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::add_ref"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::add_ref_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_release_Raw(self_vtable:
                                                     intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_ptr =
        (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                dyn IFoo,
                intercom::type_system::RawTypeSystem,
            >>::offset()) as *mut _;
    intercom::logging::trace(|l| {
        l(
            "testcrate",
            ::core::fmt::Arguments::new_v1(
                &["[", ", through ", "] Serving ", "::release_ptr"],
                &match (&self_ptr, &self_vtable, &"Foo") {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ),
        )
    });
    intercom::ComBoxData::<Foo>::release_ptr(self_ptr)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_IFoo_trait_method_Raw(self_vtable:
                                                          intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType{
    let self_combox =
        (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                dyn IFoo,
                intercom::type_system::RawTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
    let result:
            Result<<() as
                   intercom::type_system::ExternOutput<intercom::type_system::AutomationTypeSystem>>::ForeignType,
                   intercom::ComError> =
        (||
             {
                 intercom::logging::trace(|l|
                                              l("testcrate",
                                                ::core::fmt::Arguments::new_v1(&["[",
                                                                                 ", through ",
                                                                                 "] Serving ",
                                                                                 "::"],
                                                                               &match (&self_combox,
                                                                                       &self_vtable,
                                                                                       &"Foo",
                                                                                       &"trait_method")
                                                                                    {
                                                                                    (arg0,
                                                                                     arg1,
                                                                                     arg2,
                                                                                     arg3)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                  ::core::fmt::Pointer::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                  ::core::fmt::Display::fmt),
                                                                                     ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                })));
                 let self_struct: &dyn IFoo = &**self_combox;
                 let __result = self_struct.trait_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", OK"],
                        &match (&self_combox, &self_vtable, &"Foo", &"trait_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            v
        }
        Err(err) => {
            intercom::logging::trace(|l| {
                l(
                    "testcrate",
                    ::core::fmt::Arguments::new_v1(
                        &["[", ", through ", "] Serving ", "::", ", ERROR"],
                        &match (&self_combox, &self_vtable, &"Foo", &"trait_method") {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Pointer::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ],
                        },
                    ),
                )
            });
            <<() as intercom::type_system::ExternOutput<
                intercom::type_system::AutomationTypeSystem,
            >>::ForeignType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<dyn IFoo, intercom::type_system::RawTypeSystem> for Foo {
    fn vtable() -> &'static <dyn IFoo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable {
        type T = <dyn IFoo as intercom::attributes::ComInterface<
            intercom::type_system::RawTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_IFoo_query_interface_Raw,
                    add_ref: __Foo_IFoo_add_ref_Raw,
                    release: __Foo_IFoo_release_Raw,
                }
            },
            trait_method: __Foo_IFoo_trait_method_Raw,
        }
    }
}
impl intercom::HasInterface<dyn IFoo> for Foo {}
