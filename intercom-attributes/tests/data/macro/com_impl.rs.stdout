#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate intercom;
use intercom::*;
use std::mem::MaybeUninit;

// We need the IID and Vtbl to ensure this compiles.
//
// Normally these are provided by the [com_interface].
#[allow(non_camel_case_types)]
struct __Foo_AutomationVtbl;
const IID_Foo_Automation: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

#[allow(non_camel_case_types)]
struct __Foo_RawVtbl;
const IID_Foo_Raw: intercom::IID = intercom::GUID {
    data1: 0,
    data2: 0,
    data3: 0,
    data4: [0, 0, 0, 0, 0, 0, 0, 0],
};

fn get_intercom_interface_info_for_Foo() -> Vec<intercom::typelib::TypeInfo> {
    unsafe { MaybeUninit::uninit().assume_init() }
}

pub struct Foo;
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Automation as *const _ as usize }
    }
}
#[allow(non_snake_case)]
impl intercom::attributes::ComClass<Foo, intercom::type_system::RawTypeSystem> for Foo {
    #[inline(always)]
    fn offset() -> usize {
        unsafe { &intercom::ComBoxData::<Foo>::null_vtable().Foo_Raw as *const _ as usize }
    }
}
#[allow(non_upper_case_globals)]
impl
    intercom::attributes::ComImpl<
        intercom::ISupportErrorInfo,
        intercom::type_system::AutomationTypeSystem,
    > for Foo
{
    fn vtable()
     ->
         &'static <dyn intercom::ISupportErrorInfo as
intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable{
        type T = <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type Vtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                Vtbl {
                    query_interface: intercom::ComBoxData::<Foo>::query_interface_ptr,
                    add_ref: intercom::ComBoxData::<Foo>::add_ref_ptr,
                    release: intercom::ComBoxData::<Foo>::release_ptr,
                }
            },
            interface_supports_error_info:
                intercom::ComBoxData::<Foo>::interface_supports_error_info_ptr,
        }
    }
}
impl intercom::HasInterface<intercom::IUnknown> for Foo {}
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct __intercom_vtable_for_Foo {
    _ISupportErrorInfo:
        &'static <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable,
    Foo_Automation: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable,
    Foo_Raw: &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::RawTypeSystem,
    >>::VTable,
}
impl intercom::CoClass for Foo {
    type VTableList = __intercom_vtable_for_Foo;
    fn create_vtable_list() -> Self::VTableList {
        __intercom_vtable_for_Foo {
            _ISupportErrorInfo: <Foo as intercom::attributes::ComImpl<
                dyn intercom::ISupportErrorInfo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Automation: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::vtable(),
            Foo_Raw: <Foo as intercom::attributes::ComImpl<
                Foo,
                intercom::type_system::RawTypeSystem,
            >>::vtable(),
        }
    }
    fn query_interface(
        vtables: &Self::VTableList,
        riid: intercom::REFIID,
    ) -> intercom::RawComResult<intercom::RawComPtr> {
        if riid.is_null() {
            return Err(intercom::raw::E_NOINTERFACE);
        }
        unsafe {
            let riid = &*riid;
            Ok(
                if riid
                    == <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    (&vtables._ISupportErrorInfo) as
                       *const &<dyn intercom::ISupportErrorInfo as
                               intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                       as
                       *mut &<dyn intercom::ISupportErrorInfo as
                             intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                       as intercom::RawComPtr
                } else if riid
                    == <dyn intercom::ISupportErrorInfo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    (&vtables._ISupportErrorInfo) as
                       *const &<dyn intercom::ISupportErrorInfo as
                               intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                       as
                       *mut &<dyn intercom::ISupportErrorInfo as
                             intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::VTable
                       as intercom::RawComPtr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::AutomationTypeSystem,
                    >>::iid()
                {
                    &vtables.Foo_Automation
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::AutomationTypeSystem,
                        >>::VTable as intercom::RawComPtr
                } else if riid
                    == <Foo as intercom::attributes::ComInterface<
                        intercom::type_system::RawTypeSystem,
                    >>::iid()
                {
                    &vtables.Foo_Raw
                        as *const &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable
                        as *mut &<Foo as intercom::attributes::ComInterface<
                            intercom::type_system::RawTypeSystem,
                        >>::VTable as intercom::RawComPtr
                } else {
                    return Err(intercom::raw::E_NOINTERFACE);
                },
            )
        }
    }
    fn interface_supports_error_info(riid: intercom::REFIID) -> bool {
        if riid.is_null() {
            return false;
        }
        unsafe {
            let riid = &*riid;
            if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::iid()
            {
                true
            } else if riid
                == <Foo as intercom::attributes::ComInterface<
                    intercom::type_system::RawTypeSystem,
                >>::iid()
            {
                true
            } else {
                false
            }
        }
    }
}
#[allow(non_upper_case_globals)]
#[doc = "`Foo` class ID."]
pub const CLSID_Foo: intercom::CLSID = intercom::GUID {
    data1: 0u32,
    data2: 0u16,
    data3: 0u16,
    data4: [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8],
};
impl intercom::attributes::HasTypeInfo for Foo {
    fn gather_type_info() -> Vec<intercom::typelib::TypeInfo> {
        let mut r =




            // Should be VARIANT_BOOL in Automation interface.

            <[_]>::into_vec(box
                                [intercom::typelib::TypeInfo::Class(intercom::ComBox::new(intercom::typelib::CoClass::__new("Foo".into(),
                                                                                                                            intercom::GUID{data1:
                                                                                                                                               0u32,
                                                                                                                                           data2:
                                                                                                                                               0u16,
                                                                                                                                           data3:
                                                                                                                                               0u16,
                                                                                                                                           data4:
                                                                                                                                               [0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8,
                                                                                                                                                0u8],},
                                                                                                                            <[_]>::into_vec(box
                                                                                                                                                [intercom::typelib::InterfaceRef{name:
                                                                                                                                                                                     "Foo".into(),
                                                                                                                                                                                 iid_automation:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::AutomationTypeSystem>>::iid().clone(),
                                                                                                                                                                                 iid_raw:
                                                                                                                                                                                     <Foo
                                                                                                                                                                                         as
                                                                                                                                                                                         intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::iid().clone(),}]))))]);
        r.extend(<Foo as intercom::attributes::InterfaceHasTypeInfo>::gather_type_info());
        r
    }
}
impl Foo {
    fn static_method(a: u16, b: i16) {}
    fn simple_method(&self) {}
    fn arg_method(&self, a: u16) {}
    fn simple_result_method(&self) -> u16 {
        0
    }
    fn com_result_method(&self) -> ComResult<u16> {
        Ok(0)
    }
    fn rust_result_method(&self) -> Result<u16, i32> {
        Ok(0)
    }
    fn tuple_result_method(&self) -> Result<(u8, u16, u32), i32> {
        Ok(0)
    }
    fn string_method(&self, input: String) -> String {
        input
    }
    fn string_result_method(&self, input: String) -> ComResult<String> {
        Ok(input)
    }
    fn complete_method(&mut self, a: u16, b: i16) -> ComResult<bool> {
        Ok(true)
    }
    fn bool_method(&self, input: bool) -> ComResult<bool> {
        Ok(input)
    }
    fn variant_method(&self, input: Variant) -> ComResult<Variant> {
        Ok(input)
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_query_interface(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    intercom::ComBoxData::<Foo>::query_interface(
        &mut *((self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut _),
        riid,
        out,
    )
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_add_ref(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    intercom::ComBoxData::<Foo>::add_ref(
        &mut *((self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut _),
    )
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_release(self_vtable:
                                                           intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    intercom::ComBoxData::<Foo>::release_ptr(
        (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut _,
    )
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_simple_method_Automation(self_vtable:
                                                                            intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::AutomationTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<() as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_arg_method_Automation(self_vtable:
                                                                         intercom::RawComPtr,
                                                                     a:
                                                                         <u16
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::AutomationTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.arg_method((&<u16 as
                                                  intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::intercom_from(a)?).intercom_into()?);
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<() as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_simple_result_method_Automation(self_vtable:
                                                                                   intercom::RawComPtr)
 ->
     <u16 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<u16 as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::AutomationTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_result_method();
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<u16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_com_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_rust_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_tuple_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    __out1: *mut <u8 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
    __out2: *mut <u16 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
    __out3: *mut <u32 as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = v1.intercom_into()?;
                    *__out2 = v2.intercom_into()?;
                    *__out3 = v3.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_string_method_Automation(self_vtable:
                                                                            intercom::RawComPtr,
                                                                        input:
                                                                            <String
                                                                            as
                                                                            intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType)
 ->
     <String as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <String as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_method(
            (&<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({ __result.intercom_into()? })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_string_result_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <String as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <String as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_result_method(
            (&<String as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_complete_method_Automation(
    self_vtable: intercom::RawComPtr,
    a:
                                                                              <u16
                                                                              as
                                                                              intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType,
    b:
                                                                              <i16
                                                                              as
                                                                              intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternInputType,
    __out: *mut <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &mut Foo = &mut **self_combox;
        let __result = self_struct.complete_method(
            (&<u16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(a)?)
                .intercom_into()?,
            (&<i16 as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(b)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_bool_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <bool as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.bool_method(
            (&<bool as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Automation_variant_method_Automation(
    self_vtable: intercom::RawComPtr,
    input: <Variant as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    __out: *mut <Variant as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox = (self_vtable as usize
            - <Foo as intercom::attributes::ComClass<
                Foo,
                intercom::type_system::AutomationTypeSystem,
            >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.variant_method(
            (&<Variant as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::AutomationTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::AutomationTypeSystem> for Foo {
    fn vtable() -> &'static <Foo as intercom::attributes::ComInterface<
        intercom::type_system::AutomationTypeSystem,
    >>::VTable {
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::AutomationTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_Automation_query_interface,
                    add_ref: __Foo_Foo_Automation_add_ref,
                    release: __Foo_Foo_Automation_release,
                }
            },
            simple_method: __Foo_Foo_Automation_simple_method_Automation,
            arg_method: __Foo_Foo_Automation_arg_method_Automation,
            simple_result_method: __Foo_Foo_Automation_simple_result_method_Automation,
            com_result_method: __Foo_Foo_Automation_com_result_method_Automation,
            rust_result_method: __Foo_Foo_Automation_rust_result_method_Automation,
            tuple_result_method: __Foo_Foo_Automation_tuple_result_method_Automation,
            string_method: __Foo_Foo_Automation_string_method_Automation,
            string_result_method: __Foo_Foo_Automation_string_result_method_Automation,
            complete_method: __Foo_Foo_Automation_complete_method_Automation,
            bool_method: __Foo_Foo_Automation_bool_method_Automation,
            variant_method: __Foo_Foo_Automation_variant_method_Automation,
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_query_interface(
    self_vtable: intercom::RawComPtr,
    riid: <intercom::REFIID as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternInputType,
    out: *mut <intercom::RawComPtr as intercom::type_system::ExternType<
        intercom::type_system::AutomationTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::AutomationTypeSystem,
>>::ExternOutputType {
    intercom::ComBoxData::<Foo>::query_interface(&mut *((self_vtable as usize
                                                             -
                                                             <Foo as
                                                                 intercom::attributes::ComClass<Foo,
                                                                                                intercom::type_system::RawTypeSystem>>::offset())
                                                            as *mut _), riid,
                                                 out)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_add_ref(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    intercom::ComBoxData::<Foo>::add_ref(&mut *((self_vtable as usize -
                                                     <Foo as
                                                         intercom::attributes::ComClass<Foo,
                                                                                        intercom::type_system::RawTypeSystem>>::offset())
                                                    as *mut _))
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_release(self_vtable:
                                                    intercom::RawComPtr)
 ->
     <u32 as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    intercom::ComBoxData::<Foo>::release_ptr((self_vtable as usize -
                                                  <Foo as
                                                      intercom::attributes::ComClass<Foo,
                                                                                     intercom::type_system::RawTypeSystem>>::offset())
                                                 as *mut _)
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_simple_method_Raw(self_vtable:
                                                              intercom::RawComPtr)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::RawTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_method();
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<() as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_arg_method_Raw(self_vtable:
                                                           intercom::RawComPtr,
                                                       a:
                                                           <u16 as
                                                           intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType)
 ->
     <() as
intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<() as
                   intercom::type_system::ExternType<intercom::type_system::AutomationTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::RawTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.arg_method((&<u16 as
                                                  intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::intercom_from(a)?).intercom_into()?);
                 Ok({ })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<() as intercom::type_system::ExternType<
            intercom::type_system::AutomationTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_simple_result_method_Raw(self_vtable:
                                                                     intercom::RawComPtr)
 ->
     <u16 as
intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<u16 as
                   intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::RawTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result = self_struct.simple_result_method();
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<u16 as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_com_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out:
                                                                  *mut <u16 as
                                                                       intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox =
            (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.com_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_rust_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out:
                                                                   *mut <u16
                                                                        as
                                                                        intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox =
            (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.rust_result_method();
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_tuple_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    __out1:
                                                                    *mut <u8
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
    __out2:
                                                                    *mut <u16
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
    __out3:
                                                                    *mut <u32
                                                                         as
                                                                         intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox =
            (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.tuple_result_method();
        Ok({
            match __result {
                Ok((v1, v2, v3)) => {
                    *__out1 = v1.intercom_into()?;
                    *__out2 = v2.intercom_into()?;
                    *__out3 = v3.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out1 = intercom::type_system::ExternDefault::extern_default();
                    *__out2 = intercom::type_system::ExternDefault::extern_default();
                    *__out3 = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_string_method_Raw(self_vtable:
                                                              intercom::RawComPtr,
                                                          input:
                                                              <String as
                                                              intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType)
 ->
     <String as
intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType{
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result:
            Result<<String as
                   intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
                   intercom::ComError> =
        (||
             {
                 let self_combox =
                     (self_vtable as usize -
                          <Foo as
                              intercom::attributes::ComClass<Foo,
                                                             intercom::type_system::RawTypeSystem>>::offset())
                         as *mut intercom::ComBoxData<Foo>;
                 let self_struct: &Foo = &**self_combox;
                 let __result =
                     self_struct.string_method((&<String as
                                                     intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::intercom_from(input)?).intercom_into()?);
                 Ok({ __result.intercom_into()? })
             })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => <<String as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(
            err,
        )),
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_string_result_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                                     <String
                                                                     as
                                                                     intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out: *mut <String as intercom::type_system::ExternType<
        intercom::type_system::RawTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox =
            (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.string_result_method(
            (&<String as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_complete_method_Raw(
    self_vtable: intercom::RawComPtr,
    a:
                                                                <u16 as
                                                                intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    b:
                                                                <i16 as
                                                                intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out:
                                                                *mut <bool as
                                                                     intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > =
        (|| {
            let self_combox = (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
            let self_struct: &mut Foo = &mut **self_combox;
            let __result = self_struct.complete_method(
                (&<u16 as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(a)?)
                    .intercom_into()?,
                (&<i16 as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(b)?)
                    .intercom_into()?,
            );
            Ok({
                match __result {
                    Ok(v1) => {
                        *__out = v1.intercom_into()?;
                        intercom::raw::S_OK
                    }
                    Err(e) => {
                        *__out = intercom::type_system::ExternDefault::extern_default();
                        intercom::store_error(e).hresult
                    }
                }
            })
        })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_bool_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                            <bool as
                                                            intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out:
                                                            *mut <bool as
                                                                 intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > =
        (|| {
            let self_combox = (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
            let self_struct: &Foo = &**self_combox;
            let __result = self_struct.bool_method(
                (&<bool as intercom::type_system::ExternType<
                    intercom::type_system::RawTypeSystem,
                >>::intercom_from(input)?)
                    .intercom_into()?,
            );
            Ok({
                match __result {
                    Ok(v1) => {
                        *__out = v1.intercom_into()?;
                        intercom::raw::S_OK
                    }
                    Err(e) => {
                        *__out = intercom::type_system::ExternDefault::extern_default();
                        intercom::store_error(e).hresult
                    }
                }
            })
        })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_snake_case)]
#[allow(dead_code)]
#[doc(hidden)]
unsafe extern "system" fn __Foo_Foo_Raw_variant_method_Raw(
    self_vtable: intercom::RawComPtr,
    input:
                                                               <Variant as
                                                               intercom::type_system::ExternType<intercom::type_system::RawTypeSystem>>::ExternInputType,
    __out: *mut <Variant as intercom::type_system::ExternType<
        intercom::type_system::RawTypeSystem,
    >>::ExternOutputType,
) -> <intercom::raw::HRESULT as intercom::type_system::ExternType<
    intercom::type_system::RawTypeSystem,
>>::ExternOutputType {
    use intercom::type_system::{IntercomFrom, IntercomInto};
    let result: Result<
        <intercom::raw::HRESULT as intercom::type_system::ExternType<
            intercom::type_system::RawTypeSystem,
        >>::ExternOutputType,
        intercom::ComError,
    > = (|| {
        let self_combox =
            (self_vtable as usize
                - <Foo as intercom::attributes::ComClass<
                    Foo,
                    intercom::type_system::RawTypeSystem,
                >>::offset()) as *mut intercom::ComBoxData<Foo>;
        let self_struct: &Foo = &**self_combox;
        let __result = self_struct.variant_method(
            (&<Variant as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::intercom_from(input)?)
                .intercom_into()?,
        );
        Ok({
            match __result {
                Ok(v1) => {
                    *__out = v1.intercom_into()?;
                    intercom::raw::S_OK
                }
                Err(e) => {
                    *__out = intercom::type_system::ExternDefault::extern_default();
                    intercom::store_error(e).hresult
                }
            }
        })
    })();
    use intercom::ErrorValue;
    match result {
        Ok(v) => v,
        Err(err) => {
            <<intercom::raw::HRESULT as intercom::type_system::ExternType<
                intercom::type_system::RawTypeSystem,
            >>::ExternOutputType as ErrorValue>::from_error(intercom::store_error(err))
        }
    }
}
#[allow(non_upper_case_globals)]
impl intercom::attributes::ComImpl<Foo, intercom::type_system::RawTypeSystem> for Foo {
    fn vtable()
     ->
         &'static <Foo as
intercom::attributes::ComInterface<intercom::type_system::RawTypeSystem>>::VTable{
        type T = <Foo as intercom::attributes::ComInterface<
            intercom::type_system::RawTypeSystem,
        >>::VTable;
        &T {
            __base: {
                type TVtbl = <dyn intercom::IUnknown as intercom::attributes::ComInterface<
                    intercom::type_system::AutomationTypeSystem,
                >>::VTable;
                TVtbl {
                    query_interface: __Foo_Foo_Raw_query_interface,
                    add_ref: __Foo_Foo_Raw_add_ref,
                    release: __Foo_Foo_Raw_release,
                }
            },
            simple_method: __Foo_Foo_Raw_simple_method_Raw,
            arg_method: __Foo_Foo_Raw_arg_method_Raw,
            simple_result_method: __Foo_Foo_Raw_simple_result_method_Raw,
            com_result_method: __Foo_Foo_Raw_com_result_method_Raw,
            rust_result_method: __Foo_Foo_Raw_rust_result_method_Raw,
            tuple_result_method: __Foo_Foo_Raw_tuple_result_method_Raw,
            string_method: __Foo_Foo_Raw_string_method_Raw,
            string_result_method: __Foo_Foo_Raw_string_result_method_Raw,
            complete_method: __Foo_Foo_Raw_complete_method_Raw,
            bool_method: __Foo_Foo_Raw_bool_method_Raw,
            variant_method: __Foo_Foo_Raw_variant_method_Raw,
        }
    }
}
impl intercom::HasInterface<Foo> for Foo {}
