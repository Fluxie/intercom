project (test_lib)
include(ExternalProject)

# Determine the name of the binary.
# The binary is generated by Rust compiler so we cannot simply deduce it automatically.
set(TESTLIB_BINARY_BUILD_NAME "${CMAKE_SHARED_LIBRARY_PREFIX}test_lib${CMAKE_SHARED_LIBRARY_SUFFIX}" )

set(TESTLIB_WORKSPACE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/..")

# Determine the parameters based on the build type.
if( "${CMAKE_BUILD_TYPE}" STREQUAL "Release" )
    set(TESTLIB_BINARY_BUILD_DIRECTORY "${TESTLIB_WORKSPACE_DIR}/target/release" )
    set(TESTLIB_BUILD_ARGUMENT_RELEASE "--release")
else()
    set(TESTLIB_BINARY_BUILD_DIRECTORY "${TESTLIB_WORKSPACE_DIR}/target/debug" )
    set(TESTLIB_BUILD_ARGUMENT_RELEASE "")
endif()
set(TESTLIB_BINARY_BUILD_PATH "${TESTLIB_BINARY_BUILD_DIRECTORY}/${TESTLIB_BINARY_BUILD_NAME}" )
set(TESTLIB_IMPORT_BUILD_PATH "${TESTLIB_BINARY_BUILD_PATH}.lib" )

set(TESTLIB_LOCATION "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/${TESTLIB_BINARY_BUILD_NAME}" )
set(TESTLIB_IMPORT_LOCATION "${TESTLIB_LOCATION}.lib" )

# Build instructions for the library.
file(GLOB TESTLIB_SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/src)
add_custom_command(
        OUTPUT ${TESTLIB_BINARY_BUILD_PATH}
        COMMAND cargo build ${TESTLIB_BUILD_ARGUMENT_RELEASE}
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        DEPENDS ${TESTLIB_SOURCES})

# On Windows the DLLs are linked with the help of an import library.
# Carge sets the name of the import library to "<library>.dll.lib".
if( WIN32 )

    # Import library is required on Windows.
    add_custom_target( testlib_dll DEPENDS ${TESTLIB_BINARY_BUILD_PATH} ${TESTLIB_IMPORT_BUILD_PATH} )

    # Also embed the typelib into the dll.
    add_custom_command(
        TARGET testlib_dll POST_BUILD
            COMMAND cargo run embed-typelib ${TESTLIB_BINARY_BUILD_PATH}
            WORKING_DIRECTORY ${TESTLIB_WORKSPACE_DIR}/../intercom-cli
    )

    # Import library is required on Windows.
    add_custom_target( testlib DEPENDS testlib_dll )

else()

    # No import library is required.
    add_custom_target( testlib DEPENDS ${TESTLIB_BINARY_BUILD_PATH} )

endif()

add_custom_command(
        TARGET testlib POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy ${TESTLIB_BINARY_BUILD_PATH} ${TESTLIB_LOCATION}
        DEPENDS ${TESTLIB_BINARY_BUILD_PATH} )

# Publish as a library.
add_library(test_lib SHARED IMPORTED GLOBAL)
add_dependencies(test_lib testlib)
set_target_properties(test_lib PROPERTIES IMPORTED_LOCATION "${TESTLIB_BINARY_BUILD_PATH}")
set_target_properties(test_lib PROPERTIES IMPORTED_IMPLIB "${TESTLIB_IMPORT_BUILD_PATH}")

# Unfortunately Rust has a poor support for "soname".
# See the following discussions
# - https://github.com/rust-lang/rust/issues/37529
# - https://github.com/rust-lang/cargo/issues/5045
#
# Without this the NEEDED path in the binaries that link to this library are wrong.
# Even if the CMAKE_RUNTIME_OUTPUT_DIRECTORY is set to a custom directory the
# NEEDED path to this library within the executable is still set as if the compiled exectubale
# was located in the default target. e.g. CMAKE_BINARY_DIR/test/<executable>/
# Example:
# - Wrong relative path: "../../bin/lib/libtest_lib.so => not found"
# - Should have been: "./lib/libtest_lib.so"
#
# CMake: IMPORTED_NO_SONAME: Specifies that an IMPORTED shared library target has no "soname".
# Set this property to true for an imported shared library file that has no "soname" field.
# CMake may adjust generated link commands for some platforms to prevent the linker
# from using the path to the library in place of its missing soname. Ignored for non-imported targets.
set_target_properties(test_lib PROPERTIES IMPORTED_NO_SONAME TRUE)
